/*
 * functionItself.cpp
 *
 *  Created on: Jan 29, 2020
 *      Author: vlad
 */



#include "functionItself.hpp"
#include <iostream>
#include <cmath>
using namespace std;



int Function::universalSpecter (int (*fp)(void) // pointer to the executed generator function
								,int length // amount of generated numbers (changed in the process to newLength)
								,int maxF // maximal number allowed
								,const int axes // amount of dimensions in array
								,int* specterArray // pointer to the array
 								)
/*
 * Function fills the array with a specter of numbers,
 * generated by a function, that (*fp) points to.
 * Amount of numbers generated is changed (LCM (length, maxF))
 * so that there will be enough coordinates.
 * Possible problems:
 * 1) Function generates a number that is >maxF
 * 	  (fixed by assigning a value to a variable with % maxF)
 * 2) Wrong parameters passed to function (axes or maxF) - can't be fixed in C++
 */
{
	int newLength = LCM (length, axes);
	int currentCoordinate = 0;
	int pointerIndex;
	int i = 0;
	while (i < newLength)
	{
		pointerIndex = 0;
		for (int j = 0; j < axes; ++j)
		{
			currentCoordinate = fp() % maxF;
			++i;
			pointerIndex += currentCoordinate;
			if (j != axes-1) pointerIndex *= maxF;
		}
		(*(specterArray+pointerIndex))++;
	}

	int nonZeroElementCounter = 0;
	for (int i = 0; i < pow(maxF, axes); i++)
	{
		if (*(specterArray+i) != 0)
		{
			++nonZeroElementCounter;
		}

	}
	return nonZeroElementCounter;
};

int Function::GCD (int a, int b)
{
	int max = (a >= b) ? a : b;
	int min = (a >= b) ? b : a;
	while (min > 0)
	{
		max = max % min;
		int tmp = max;
		max = min;
		min = tmp;
	}
	return max;
}

int Function::LCM (int a, int b)
{
	return (int)(((long long)a*b) / GCD(a, b));
}
