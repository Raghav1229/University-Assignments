/*
 * functionItself.cpp
 *
 *  Created on: Jan 29, 2020
 *      Author: vlad
 */



#include <iostream>
#include <string>
#include <cmath>
#include <fstream>
#include <sstream>

#include "specterBuilder.hpp"
using namespace std;


Specter::Specter(int length,int maxF, int axes, int* specterArray)
{
	(*this).length = length;
	(*this).maxF = maxF;
	(*this).axes = axes;
	(*this).specter = specterArray;
}


int Specter::buildSpecter (Function& function // pointer to the executed generator function
 								)
/*
 * Function fills the array with a specter of numbers,
 * generated by a function, that (*fp) points to.
 * Amount of numbers generated is changed (LCM (length, maxF))
 * so that there will be enough coordinates.
 * Possible problems:
 * 1) Function generates a number that is >maxF
 * 	  (fixed by assigning a value to a variable with % maxF)
 * 2) Wrong parameters passed to function (axes or maxF) - can't be fixed in C++
 */
{
	int newLength = LCM (length, axes);
	int currentCoordinate = 0;
	int pointerIndex;
	int i = 0;
	while (i < newLength)
	{
		pointerIndex = 0;
		for (int j = 0; j < axes; ++j)
		{
			currentCoordinate = function.next() % maxF;
			++i;
			pointerIndex += currentCoordinate;
			if (j != axes-1) pointerIndex *= maxF;
		}
		(*(specter+pointerIndex))++;
	}

	int nonZeroElementCounter = 0;
	for (int i = 0; i < pow(maxF, axes); i++)
	{
		if (*(specter+i) != 0)
		{
			++nonZeroElementCounter;
		}

	}
	return nonZeroElementCounter;
};

int Specter::GCD (int a, int b)
{
	int max = (a >= b) ? a : b;
	int min = (a >= b) ? b : a;
	while (min > 0)
	{
		max = max % min;
		int tmp = max;
		max = min;
		min = tmp;
	}
	return max;
}

int Specter::LCM (int a, int b)
{
	return (int)(((long long)a*b) / GCD(a, b));
}


// Converts specter to string.
string Specter::specter2String ()
{
	counter = 0;
	string html = "";
	html += "<style>"
      "table{"
      "padding: 10px;"
      "border: 1px solid black;"
      "border-collapse: collapse;"
	  "background-color:#c75e5e;"
      "}"
	 "table td {border:solid 5px red;"
            "border-top-color:#FEB9B9;"
            "border-right-color:#B22222;"
            "border-bottom-color:#B22222;"
            "border-left-color:#FEB9B9;} </style>";

	html += "<html> \n";
	html += "<body> \n";

	html += buildTable(axes, 0);

	html += "</body> \n";
	html += "</html> \n";
	return html;
}

// Writes out HTML to cout.
int Specter::specter2cout ()
{
	cout << specter2String ();
	return counter;
}


// Writes out HTML to file (given the filename)
int Specter::specter2File (string fileName) // the name of the file where the output is written
{
	ofstream fout (fileName);
	fout << specter2String ();
	fout.close();
	return counter;
}

/* Helper recursive function to build the structure of HTML file.
 * Depth of recursion = amount of axes.
 * (each new axis = new nested table)
 */

string Specter::buildTable(int depth // depth of recursion
					   	 , int index) /* incomplete index from the previous recursion call
											  *	(see if-condition to understand how it is used)
											  */
{
	if (depth == 0)
	{

	}
	else
	{
		string tableHTML = "";
		tableHTML +="<table> \n";
		for (int i = 0; i < maxF; i++)
		{
		tableHTML +="<tr> \n";
		tableHTML +="<td> \n";

		if (depth > 1)
		{
			tableHTML += buildTable (depth-1, (index*maxF)+i);
		}
		else
		{

			int tmp = *(specter+i);
			counter++;
			stringstream ss;
			ss << tmp;
			string str = ss.str();
			tableHTML += str;

		}

		tableHTML += "</td> \n";
		tableHTML +="</tr> \n";
		}
		tableHTML +="</table> \n";
		return tableHTML;
	}
}

void changeArrayPointer (int* pInt)
{
	(*this).specter = pInt;
}

